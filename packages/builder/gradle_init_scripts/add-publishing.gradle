import groovy.json.JsonSlurper

allprojects { project ->
    if (!project.plugins.hasPlugin("maven-publish")) {
        project.plugins.apply("maven-publish")
    }

    // Configure android.publishing.singleVariant before projects are evaluated
    // This needs to happen after the Android plugin is applied but before evaluation completes
    project.afterEvaluate { proj ->
        if (proj.plugins.hasPlugin("com.android.library")) {
            try {
                if (proj.hasProperty('android')) {
                    def android = proj.android
                    if (android.hasProperty('publishing')) {
                        android.publishing {
                            singleVariant("release")
                        }
                    }
                }
            } catch (Exception e) {
                println "Warning: Could not configure singleVariant for ${proj.name}: ${e.message}"
            }
        }
    }
}

gradle.projectsEvaluated {
    allprojects { project ->

        // Target only Android library modules
        if (project.plugins.hasPlugin("com.android.library")) {
            
            // Flag to control whether to build with codegen support
            def buildWithCodegen = project.hasProperty('buildWithCodegen') ? project.property('buildWithCodegen').toBoolean() : false
            
            def getCodegenName = {
                def pkgJson = file("${project.projectDir}/../package.json")
                if (pkgJson.exists()) {
                    try {
                        def json = new JsonSlurper().parseText(pkgJson.text)
                        return json.codegenConfig?.name
                    } catch (Exception e) { return null }
                }
                return null
            }

            def codegenName = buildWithCodegen ? getCodegenName() : null

            // Task to extract static libs from .cxx to jniLibs
            def extractTask = project.tasks.register("extractCodegenBinaries") {
                onlyIf { codegenName != null }
                doLast {
                    def appCxxDir = file("${rootProject.projectDir}/app/.cxx")
                    def archs = ["arm64-v8a", "armeabi-v7a", "x86", "x86_64"]
                    def moduleFolder = "${codegenName}_autolinked_build"
                    archs.each { arch ->
                        def staticLib = fileTree(dir: appCxxDir, include: "**/$moduleFolder/**/libreact_codegen_${codegenName}.a")
                            .find { it.path.contains(arch) }
                        if (staticLib) {
                            def destDir = file("${project.projectDir}/src/main/assets/$arch")
                            destDir.mkdirs()
                            copy { from staticLib; into destDir }
                        }
                    }
                    // Metadata for the consumer
                    def metaDir = file("${project.projectDir}/src/main/assets/meta")
                    metaDir.mkdirs()
                    file("${metaDir}/codegen_name.txt").text = codegenName
                }
            }

            // Task to package headers
            def packageHeadersTask = project.tasks.register("packageCppHeaders", Zip) {
                dependsOn 'generateCodegenArtifactsFromSchema'
                archiveClassifier = 'headers'
                from("${project.buildDir}/generated/source/codegen/jni") { include "**/*.h" }
                from("${project.projectDir}/src/main/jni") { include "**/*.h" }
                destinationDirectory = file("${project.buildDir}/outputs/cpp")
                archiveFileName = "cpp-headers.zip"
            }

            if (project.tasks.findByName('bundleReleaseAar')) {
                project.tasks.bundleReleaseAar.dependsOn(extractTask)
            }

            try {
                if (project.hasProperty('android')) {
                    def android = project.android
                    
                    android.sourceSets.main {
                        assets.srcDirs += ["src/main/assets"]
                    }
                    // -------------------------------------------------------------

                }
            } catch (Exception e) {
                println "Warning: Could not configure Android settings for ${project.name}: ${e.message}"
            }

            try {
                publishing {
                    publications {
                        release(MavenPublication) {
                            // This is needed for dependencies to be automatically populated in the POM
                            from project.components.release

                            groupId = 'org.rnrepo.public'
                            artifactId = project.findProperty('rnrepoArtifactId')
                            version = project.findProperty('rnrepoPublishVersion')

                            // We re-add the AAR artifacts here in order to have the classifier specified
                            artifacts.removeAll { it.classifier == null }
                            def aarTask = project.tasks.findByName('bundleReleaseAar')
                            if (aarTask) {
                                def baseClassifier = project.findProperty('rnrepoClassifier') ?: ''
                                def finalClassifier = codegenName ? "${baseClassifier}-codegen" : baseClassifier
                                artifact(aarTask.outputs.files.singleFile) {
                                    classifier = finalClassifier
                                    extension = 'aar'
                                }
                            }

                            if (codegenName) {
                                artifact(packageHeadersTask) {
                                    classifier = 'headers'
                                    extension = 'zip'
                                }
                            }

                            pom {
                                withXml {
                                    def rootNode = asNode()
                                    def propertiesNode = rootNode.children().find { it.name() == 'properties' }
                                    if (!propertiesNode) {
                                        propertiesNode = rootNode.appendNode('properties')
                                    }

                                    def buildDurationSeconds = project.hasProperty('rnrepoBuildDurationSeconds') ? project.property('rnrepoBuildDurationSeconds') : null

                                    if (buildDurationSeconds != null) {
                                        propertiesNode.appendNode('rnrepo.buildDurationSeconds', String.format("%.3f", buildDurationSeconds))
                                    }

                                    def cpuInfo = project.findProperty('rnrepoCpuInfo')
                                    if (cpuInfo != null) {
                                        propertiesNode.appendNode('rnrepo.cpuinfo', cpuInfo)
                                    }

                                    def buildUrl = project.findProperty('rnrepoBuildUrl')
                                    if (buildUrl != null) {
                                        propertiesNode.appendNode('rnrepo.buildUrl', buildUrl)
                                    }
                                }
                                licenses {
                                    license {
                                        name = project.findProperty('rnrepoLicenseName')
                                        url = project.findProperty('rnrepoLicenseUrl')
                                    }
                                }
                            }
                        }
                    }
                    repositories {
                        mavenLocal()
                    }
                }

                // Disable Gradle Module Metadata generation
                tasks.matching { it.name.startsWith('generateMetadataFileFor') }.configureEach {
                    enabled = false
                }

                // Print execution time for bundleReleaseAar task (including dependencies) and expose as metadata
                def bundleReleaseAarTask = project.tasks.findByName('bundleReleaseAar')
                if (bundleReleaseAarTask) {
                    def startTime = System.currentTimeMillis()
                    project.extensions.extraProperties.set('rnrepoBuildDurationSeconds', null)

                    bundleReleaseAarTask.doLast {
                        def endTime = System.currentTimeMillis()
                        def duration = endTime - startTime
                        def seconds = duration / 1000.0
                        project.extensions.extraProperties.set('rnrepoBuildDurationSeconds', seconds)
                        println "⏱️  bundleReleaseAar (wall clock, deps included) completed in ${String.format('%.3f', seconds)} seconds"
                    }
                }
                // add generatePomFileForReleasePublication dependsOn bundleReleaseAarTask for build duration variable
                def generatePomFileTask = project.tasks.findByName('generatePomFileForReleasePublication')
                if (generatePomFileTask && bundleReleaseAarTask) {
                    generatePomFileTask.dependsOn(bundleReleaseAarTask)
                    // Ensure headers are ready before POM is generated
                    generatePomFileTask.dependsOn(packageHeadersTask)
                }
            } catch (Exception e) {
                println "Warning: Could not configure publishing for ${project.name}: ${e.message}"
            }
        }
    }
}