allprojects { project ->
    if (!project.plugins.hasPlugin("maven-publish")) {
        project.plugins.apply("maven-publish")
    }

    // Configure android.publishing.singleVariant before projects are evaluated
    // This needs to happen after the Android plugin is applied but before evaluation completes
    project.afterEvaluate { proj ->
        if (proj.plugins.hasPlugin("com.android.library")) {
            try {
                if (proj.hasProperty('android')) {
                    def android = proj.android
                    if (android.hasProperty('publishing')) {
                        android.publishing {
                            singleVariant("release")
                        }
                    }
                }
            } catch (Exception e) {
                println "Warning: Could not configure singleVariant for ${proj.name}: ${e.message}"
            }
        }
    }
}

def configureCodegenTasks(project) {
    // Codegen name is passed from build-library-android.ts when building codegen version
    def codegenName = project.hasProperty('rnrepoCodegenName') 
        ? project.property('rnrepoCodegenName') 
        : null

    // Task to extract static libs from .cxx to jniLibs
    def extractTask = project.tasks.register("extractCodegenBinaries") {
        onlyIf { codegenName != null }
        doLast {
            def appCxxDir = file("${rootProject.projectDir}/app/.cxx")
            def archs = ["arm64-v8a", "armeabi-v7a", "x86", "x86_64"]
            def moduleFolder = "${codegenName}_autolinked_build"
            archs.each { arch ->
                def staticLib = fileTree(dir: appCxxDir, include: "**/$moduleFolder/**/libreact_codegen_${codegenName}.a")
                    .find { it.path.contains(arch) }
                if (staticLib) {
                    def destDir = file("${project.projectDir}/src/main/assets/$arch")
                    destDir.mkdirs()
                    copy { from staticLib; into destDir }
                }
            }
            // Metadata for the consumer
            def metaDir = file("${project.projectDir}/src/main/assets/meta")
            metaDir.mkdirs()
            file("${metaDir}/codegen_name.txt").text = codegenName
        }
    }

    // Task to package headers - must run after codegen generation
    def packageHeadersTask = project.tasks.register("packageCppHeaders") {
        onlyIf { codegenName != null }
        dependsOn 'generateCodegenArtifactsFromSchema'
        doLast {
            def headersSourceDir = file("${project.buildDir}/generated/source/codegen/jni")
            def headersDestDir = file("${project.projectDir}/src/main/assets/headers")
            
            if (headersSourceDir.exists()) {
                headersDestDir.mkdirs()
                copy {
                    from headersSourceDir
                    into headersDestDir
                    include "**/*.h"
                }
                println "üì¶ Packaged codegen headers to assets/headers"
            } else {
                println "‚ö†Ô∏è  Warning: Headers source directory not found at ${headersSourceDir}"
            }
        }
    }

    // Hook into mergeReleaseAssets to ensure files are copied before AGP scans assets
    def mergeAssetsTask = project.tasks.findByName('mergeReleaseAssets')
    if (mergeAssetsTask) {
        mergeAssetsTask.dependsOn(extractTask)
        mergeAssetsTask.dependsOn(packageHeadersTask)
    }

    try {
        if (project.hasProperty('android')) {
            def android = project.android
            
            android.sourceSets.main {
                assets.srcDirs += ["src/main/assets"]
            }
        }
    } catch (Exception e) {
        println "Warning: Could not configure Android settings for ${project.name}: ${e.message}"
    }

    return [codegenName: codegenName, packageHeadersTask: packageHeadersTask]
}

gradle.projectsEvaluated {
    allprojects { project ->

        // Target only Android library modules
        if (project.plugins.hasPlugin("com.android.library")) {
            
            def codegenConfig = configureCodegenTasks(project)
            def codegenName = codegenConfig.codegenName
            def packageHeadersTask = codegenConfig.packageHeadersTask

            try {
                publishing {
                    publications {
                        release(MavenPublication) {
                            // This is needed for dependencies to be automatically populated in the POM
                            from project.components.release

                            groupId = 'org.rnrepo.public'
                            artifactId = project.findProperty('rnrepoArtifactId')
                            version = project.findProperty('rnrepoPublishVersion')

                            // We re-add the AAR artifacts here in order to have the classifier specified
                            artifacts.removeAll { it.classifier == null }
                            def aarTask = project.tasks.findByName('bundleReleaseAar')
                            if (aarTask) {
                                def baseClassifier = project.findProperty('rnrepoClassifier') ?: ''
                                def finalClassifier = codegenName ? "${baseClassifier}-codegen" : baseClassifier
                                artifact(aarTask.outputs.files.singleFile) {
                                    classifier = finalClassifier
                                    extension = 'aar'
                                }
                            }


                            pom {
                                withXml {
                                    def rootNode = asNode()
                                    def propertiesNode = rootNode.children().find { it.name() == 'properties' }
                                    if (!propertiesNode) {
                                        propertiesNode = rootNode.appendNode('properties')
                                    }

                                    def buildDurationSeconds = project.hasProperty('rnrepoBuildDurationSeconds') ? project.property('rnrepoBuildDurationSeconds') : null

                                    if (buildDurationSeconds != null) {
                                        propertiesNode.appendNode('rnrepo.buildDurationSeconds', String.format("%.3f", buildDurationSeconds))
                                    }

                                    def cpuInfo = project.findProperty('rnrepoCpuInfo')
                                    if (cpuInfo != null) {
                                        propertiesNode.appendNode('rnrepo.cpuinfo', cpuInfo)
                                    }

                                    def buildUrl = project.findProperty('rnrepoBuildUrl')
                                    if (buildUrl != null) {
                                        propertiesNode.appendNode('rnrepo.buildUrl', buildUrl)
                                    }
                                }
                                licenses {
                                    license {
                                        name = project.findProperty('rnrepoLicenseName')
                                        url = project.findProperty('rnrepoLicenseUrl')
                                    }
                                }
                            }
                        }
                    }
                    repositories {
                        mavenLocal()
                    }
                }

                // Disable Gradle Module Metadata generation
                tasks.matching { it.name.startsWith('generateMetadataFileFor') }.configureEach {
                    enabled = false
                }

                // Print execution time for bundleReleaseAar task (including dependencies) and expose as metadata
                def bundleReleaseAarTask = project.tasks.findByName('bundleReleaseAar')
                if (bundleReleaseAarTask) {
                    def startTime = System.currentTimeMillis()
                    project.extensions.extraProperties.set('rnrepoBuildDurationSeconds', null)

                    bundleReleaseAarTask.doLast {
                        def endTime = System.currentTimeMillis()
                        def duration = endTime - startTime
                        def seconds = duration / 1000.0
                        project.extensions.extraProperties.set('rnrepoBuildDurationSeconds', seconds)
                        println "‚è±Ô∏è  bundleReleaseAar (wall clock, deps included) completed in ${String.format('%.3f', seconds)} seconds"
                    }
                }
                // add generatePomFileForReleasePublication dependsOn bundleReleaseAarTask for build duration variable
                def generatePomFileTask = project.tasks.findByName('generatePomFileForReleasePublication')
                if (generatePomFileTask && bundleReleaseAarTask) {
                    generatePomFileTask.dependsOn(bundleReleaseAarTask)
                }
            } catch (Exception e) {
                println "Warning: Could not configure publishing for ${project.name}: ${e.message}"
            }
        }
    }
}